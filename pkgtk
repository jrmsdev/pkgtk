#!/usr/bin/env tclsh8.6

# Copyright (c) Jerem√≠as Casteglione <jrmsdev@gmail.com>.
# See LICENSE file.

package require Tcl 8.6
package require Tk 8.6

#
# global vars
#
set pkgbuttons_curstate {disabled}
set pkgtree_selected ""
set pkgcmd_run 0
set pkgcmd_top .pkgcmdview

#
# view pkg upgrade command
#
proc view_pkgcmd_upgrade {} {
    global pkgtree_selected
    set pkg $pkgtree_selected
    pkgcmd_view "upgrade" $pkg
}

#
# view pkg remove command
#   TODO: support adding -R arg
#
proc view_pkgcmd_remove {} {
    global pkgtree_selected
    set pkg $pkgtree_selected
    pkgcmd_view "remove" $pkg
}

#
# view pkg clean cache command
#
proc view_pkgcmd_clean_cache {} {
    pkgcmd_view "clean" "-a"
}

#
# view pkg install command
#
proc view_pkgcmd_install {} {
    global pkgtree_selected
    set pkg $pkgtree_selected
    pkgcmd_view "install" $pkg
}

#
# view pkg autoremove command
#
proc view_pkgcmd_autoremove {} {
    pkgcmd_view "autoremove"
}

#
# run pkg command
#
proc pkgcmd_dorun {w cmd args} {
    tkbusy_hold
    try {
        $w.cmdout insert end "pkg $cmd\n\n"
        if {$args != "NONE"} {
            $w.cmdout insert end [exec pkg $cmd -y $args]
        } else {
            $w.cmdout insert end [exec pkg $cmd -y]
        }
        $w.cmdout configure -state "disabled"
    } trap CHILDSTATUS {results options} {
        show_error $results
    }
    tkbusy_forget
}

#
# run pkg command (dry run), whitout applying any changes to the system
#
proc pkgcmd_dryrun {w cmd args} {
    tkbusy_hold
    try {
        $w.cmdout insert end "pkg $cmd (dry run) $args\n\n"
        if {$args != "NONE"} {
            $w.cmdout insert end [exec pkg $cmd -n $args]
        } else {
            $w.cmdout insert end [exec pkg $cmd -n]
        }
    } trap CHILDSTATUS {results options} {
        set rc [lindex [dict get $options -errorcode] 2]
        if {$rc > 1} {
            show_error $results
        } else {
            $w.cmdout insert end $results
        }
    }
    $w.cmdout configure -state "disabled"
    tkbusy_forget
}

#
# pkg command view
#
proc pkgcmd_view {cmd {args "NONE"} {dorun 0}} {
    global pkgcmd_run pkgcmd_top
    set pkgcmd_run 0
    set top $pkgcmd_top
    if {[winfo exists $top]} {
        destroy $top
    }
    toplevel $top
    wm transient $top .
    wm title $top "pkg $cmd"
    set w $top.view
    ttk::frame $w
    grid rowconfigure $w 0 -weight 1
    grid rowconfigure $w 1 -weight 9
    grid columnconfigure $w 0 -weight 1
    grid $w -sticky nwse
    ttk::frame $w.btn
    grid $w.btn -row 0 -column 0 -sticky nwse
    ttk::button $w.btn.run -text "Confirm $cmd" -command {set pkgcmd_run 1}
    grid $w.btn.run -row 0 -column 0 -sticky w
    ttk::button $w.btn.cancel -text "Cancel" -command {destroy $pkgcmd_top}
    grid $w.btn.cancel -row 0 -column 1 -sticky w
    text $w.cmdout
    grid $w.cmdout -row 1 -column 0 -sticky nwse
    if {$dorun} {
        pkgcmd_dorun $w $cmd $args
    } else {
        pkgcmd_dryrun $w $cmd $args
        vwait pkgcmd_run
        if {$pkgcmd_run} {
            pkgcmd_view $cmd $args 1
        }
    }
}

#
# installed pkg action buttons
#
proc pkglocal_buttons {w} {
    ttk::button $w.remove -text "Remove" -state "disabled" \
                          -command {view_pkgcmd_remove}
    grid $w.remove -row 0 -column 0 -sticky w
    ttk::button $w.upgrade -text "Upgrade" -state "disabled" \
                          -command {view_pkgcmd_upgrade}
    grid $w.upgrade -row 0 -column 1 -sticky w
}

#
# available pkg action buttons
#
proc pkgremote_buttons {w} {
    ttk::button $w.install -text {Install} -state {disabled} \
                           -command {view_pkgcmd_install}
    grid $w.install -row 0 -column 0 -sticky w
}

#
# change state of pkg action buttons
#
proc pkgbuttons_state {w state} {
    global pkgbuttons_curstate
    if {$pkgbuttons_curstate == $state} {
        return
    }
    set children [winfo children $w]
    set children_len [llength $children]
    for {set i 0} {$i < $children_len} {incr i} {
        set b [lindex $children $i]
        $b configure -state $state
    }
    set pkgbuttons_curstate $state
    update
}

#
# enable pkg action buttons
#
proc pkgbuttons_enable {w} {
    pkgbuttons_state $w {enabled}
}

#
# disable pkg action buttons
#
proc pkgbuttons_disable {w} {
    pkgbuttons_state $w {disabled}
}

#
# packages tree view
#
proc pkgtree_view {w pkgtype pkglist} {
    set paned $w
    ttk::panedwindow $paned -orient "horizontal" -takefocus 0
    grid $paned -sticky nwse

    ttk::frame $w.left -takefocus 0
    grid rowconfigure $w.left 0 -weight 1
    grid rowconfigure $w.left 1 -weight 9
    grid columnconfigure $w.left 0 -weight 1
    grid $w.left -sticky nwse

    set stats $w.left.stats
    ttk::label $stats -takefocus 0
    grid $stats -row 0 -column 0 -sticky w

    set pkgtree $w.left.pkgtree
    ttk::treeview $pkgtree -show tree -selectmode browse -takefocus 1
    grid $pkgtree -row 1 -column 0 -sticky nwse

    $paned add $w.left -weight 1

    ttk::frame $w.right -takefocus 0
    grid rowconfigure $w.right 0 -weight 1
    grid rowconfigure $w.right 1 -weight 9
    grid columnconfigure $w.right 0 -weight 1
    grid $w.right -sticky nwse

    set pkgbuttons $w.right.pkgbuttons
    ttk::frame $pkgbuttons -takefocus 0
    grid $pkgbuttons -row 0 -column 0 -sticky n

    set pkginfo $w.right.pkginfo
    ttk::label $pkginfo -takefocus 0
    grid $pkginfo -row 1 -column 0 -sticky n
    $pkginfo configure -anchor "center" -justify "left"

    $paned add $w.right -weight 9

    tkbusy_hold
    if {[string equal "Available" $pkgtype]} {
        pkgremote_buttons $pkgbuttons
    } else {
        pkglocal_buttons $pkgbuttons
    }

    set llen [llength $pkglist]
    $stats configure -text "$pkgtype packages: $llen"

    set cur_section {}
    set focus_item {}
    for {set i 0} {$i < $llen} {incr i} {
        set line [lindex $pkglist $i]
        set origin [lindex [split $line {|}] 0]
        set pkg_section [lindex [split $origin /] 0]
        set pkg_name [lindex [split $line {|}] 1]
        if {[string equal $cur_section {}]} {
            set focus_item $pkg_section
        }
        if {[string compare $pkg_section $cur_section] != 0} {
            set sid [$pkgtree insert {} end -id $pkg_section -text $pkg_section]
            set cur_section $pkg_section
        }
        set pkgid "pkglocal:$pkg_name"
        if {[string equal "Available" $pkgtype]} {
            set pkgid "pkgremote:$pkg_name"
        }
        $pkgtree insert $cur_section end -id $pkgid -text $pkg_name
    }
    tkbusy_forget

    $pkgtree focus $focus_item
    focus $pkgtree
    bind $pkgtree <<TreeviewSelect>> "pkg_show $pkgtree $pkginfo $pkgbuttons"
}

#
# view local (installed) packages
#
proc view_pkglocal {w} {
    pkgtree_view $w "Installed" [pkglist_local]
}

#
# view remote (available) packages
#
proc view_pkgremote {w} {
    pkgtree_view $w "Available" [pkglist_remote]
}

#
# dispatch view
#
proc dispatch_view {name} {
    set w .view
    if [winfo exists $w] {
        destroy $w
    }
    $name $w
}

#
# show pkg info
#
proc pkg_show {pkgtree pkginfo pkgbuttons} {
    global pkgtree_selected
    set pkgtree_selected "NONE"
    set item [$pkgtree selection]
    set query_format {%n %v (%sh)\n\n%e}
    set pkgremote 0
    if {[string equal {pkglocal:} [string range $item 0 8]]} {
        set pkg [string replace $item 0 8 {}]
        $pkginfo configure -text [exec pkg query $query_format $pkg]
        pkgbuttons_enable $pkgbuttons
        set pkgtree_selected $pkg
    } elseif {[string equal {pkgremote:} [string range $item 0 9]]} {
        set pkg [string replace $item 0 9 {}]
        $pkginfo configure -text [exec pkg rquery $query_format $pkg]
        pkgbuttons_enable $pkgbuttons
        set pkgtree_selected $pkg
    } else {
        set slen [llength [$pkgtree children $item]]
        $pkginfo configure -text "Category : $item\nPackages : $slen"
        pkgbuttons_disable $pkgbuttons
    }
}

#
# show error message
#
proc show_error {msg} {
    tk_messageBox -parent . -title "pkgtk error" -message "$msg" \
                  -type "ok" -icon "error"
}

#
# tk busy hold
#
proc tkbusy_hold {{w .}} {
    tk busy hold $w
    tk busy configure $w -cursor watch
    update
}

#
# tk busy forget
#
proc tkbusy_forget {{w .}} {
    tk busy forget $w
    update
}

#
# pkg list local (installed) packages
#
proc pkglist_local {} {
    try {
        return [split [exec pkg query -e {%a == 0} {%o|%n-%v} | sort -u]]
    } trap CHILDSTATUS {results options} {
        show_error $results
    }
}

#
# pkg list remote (available) packages
#
proc pkglist_remote {} {
    try {
        return [split [exec pkg rquery -a {%o|%n-%v} | sort]]
    } trap CHILDSTATUS {results options} {
        show_error $results
    }
}

#
# main menu
#
proc main_menu {} {
    menu .menu
    . configure -menu .menu

    menu .menu.packages -tearoff 0
    .menu add cascade -label "Packages" -underline 0 -menu .menu.packages
    .menu.packages add command -label "Installed" -underline 0 \
                               -command {dispatch_view view_pkglocal}
    .menu.packages add command -label "Upgrade" -underline 0 \
                               -command {quit 128}
    .menu.packages add separator
    .menu.packages add command -label "Available" -underline 0 \
                               -command {dispatch_view view_pkgremote}
    .menu.packages add command -label "Search" -underline 0 \
                               -command {quit 128}
    .menu.packages add separator
    .menu.packages add command -label "Autoremove" -underline 4 \
                               -command {view_pkgcmd_autoremove}
    .menu.packages add command -label "Clean cache" -underline 0 \
                               -command {view_pkgcmd_clean_cache}
    .menu.packages add separator
    .menu.packages add command -label "Quit" -underline 0 -command {quit 0}
}

#
# exit main loop
#
proc quit {rc} {
    destroy .
    exit $rc
}

#
# main
#
wm title . "FreeBSD package manager"
wm minsize . 800 600
grid rowconfigure . 0 -weight 1
grid columnconfigure . 0 -weight 1
. configure -padx 1 -pady 1
main_menu
dispatch_view view_pkglocal
