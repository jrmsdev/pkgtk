#!/usr/bin/env tclsh8.6

package require Tk

#
# view packages tree
#
proc pkgtree_view {w pkgtype pkglist} {
    ttk::frame $w
    grid rowconfigure $w 0 -weight 1
    grid rowconfigure $w 1 -weight 9
    grid columnconfigure $w 0 -weight 1
    grid columnconfigure $w 1 -weight 3
    grid $w -sticky nwse
    ttk::label $w.stats -takefocus 0
    grid $w.stats -row 0 -column 0 -sticky w
    ttk::treeview $w.pkgtree -show tree -selectmode browse -takefocus 1
    grid $w.pkgtree -row 1 -column 0 -sticky nwse
    ttk::label $w.pkginfo -takefocus 1
    grid $w.pkginfo -row 1 -column 1 -sticky nw
    tkbusy_hold
    set llen [llength $pkglist]
    $w.stats configure -text "$pkgtype packages: $llen"
    set cur_section {}
    set focus_item {}
    for {set i 0} {$i < $llen} {incr i} {
        set line [lindex $pkglist $i]
        set origin [lindex [split $line {|}] 0]
        set pkg_section [lindex [split $origin /] 0]
        set pkg_name [lindex [split $line {|}] 1]
        if {[string equal $cur_section {}]} {
            set focus_item $pkg_section
        }
        if {[string compare $pkg_section $cur_section] != 0} {
            set sid [$w.pkgtree insert {} end -id $pkg_section -text $pkg_section]
            set cur_section $pkg_section
        }
        set pkgid "pkglocal:$pkg_name"
        if {[string equal "Available" $pkgtype]} {
            set pkgid "pkgremote:$pkg_name"
        }
        $w.pkgtree insert $cur_section end -id $pkgid -text $pkg_name
    }
    tkbusy_forget
    $w.pkgtree focus $focus_item
    focus $w.pkgtree
    bind $w.pkgtree <<TreeviewSelect>> {pkg_show %W}
}

#
# view local (installed) packages
#
proc view_pkglocal {w} {
    pkgtree_view $w "Installed" [pkglist_local]
}

#
# view remote (available) packages
#
proc view_pkgremote {w} {
    pkgtree_view $w "Available" [pkglist_remote]
}

#
# dispatch view
#
proc dispatch_view {name} {
    set w .view
    if [winfo exists $w] {
        destroy $w
    }
    $name $w
}

#
# show pkg info
#
proc pkg_show {pkgtree} {
    set w [winfo parent $pkgtree]
    set item [$pkgtree selection]
    set query_format {%n %v (%sh)\n\n%e}
    if {[string equal {pkglocal:} [string range $item 0 8]]} {
        set pkg [string replace $item 0 8 {}]
        $w.pkginfo configure -text [exec pkg query $query_format $pkg]
    } elseif {[string equal {pkgremote:} [string range $item 0 9]]} {
        set pkg [string replace $item 0 9 {}]
        $w.pkginfo configure -text [exec pkg rquery $query_format $pkg]
    } else {
        set slen [llength [$pkgtree children $item]]
        $w.pkginfo configure -text "Category : $item\nPackages : $slen"
    }
}

#
# show error message
#
proc show_error {msg} {
    tk_messageBox -parent . -title "pkgtk error" -message "$msg" -type ok
}

#
# tk busy hold
#
proc tkbusy_hold {{w .}} {
    tk busy hold $w
    tk busy configure $w -cursor watch
    update
}

#
# tk busy forget
#
proc tkbusy_forget {{w .}} {
    tk busy forget $w
    update
}

#
# pkg list local (installed) packages
#
proc pkglist_local {} {
    try {
        return [split [exec pkg query -e {%a == 0} {%o|%n-%v} | sort -u]]
    } trap CHILDSTATUS {results options} {
        show_error [dict get $options -errorinfo]
    }
}

#
# pkg list remote (available) packages
#
proc pkglist_remote {} {
    try {
        return [split [exec pkg rquery -a {%o|%n-%v} | sort]]
    } trap CHILDSTATUS {results options} {
        show_error [dict get $options -errorinfo]
    }
}

#
# exit main loop
#
proc quit {rc} {
    destroy .
    exit $rc
}

#
# sleep func
#
proc sleep {t} {
    after [expr round($t * 1000)]
}

#
# main menu
#
proc main_menu {} {
    menu .menu
    . configure -menu .menu

    menu .menu.packages
    .menu add cascade -label "Packages" -underline 0 -menu .menu.packages
    .menu.packages add command -label "Installed" -underline 0 \
                               -command {dispatch_view view_pkglocal}
    .menu.packages add command -label "Available" -underline 0 \
                               -command {dispatch_view view_pkgremote}

    .menu add command -label "Quit" -underline 0 -command {quit 0}
}

#
# main
#
proc main {} {
    wm title . pkgtk
    wm minsize . 800 600
    grid rowconfigure . 0 -weight 1
    grid columnconfigure . 0 -weight 1
    . configure -padx 1 -pady 1
    main_menu
    dispatch_view view_pkglocal
}

main
