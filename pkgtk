#!/usr/bin/env tclsh8.6

package require Tk

#
# global vars
#
set pkgbuttons_curstate {disabled}
set pkgtree_selected ""
set pkgcmd_run 0

#
# view pkg install command
#
proc view_pkgcmd_install {} {
    global pkgtree_selected
    set pkg $pkgtree_selected
    pkgcmd_view "install" $pkg
}

#
# view pkg autoremove command
#
proc view_pkgcmd_autoremove {} {
    pkgcmd_view "autoremove"
}

#
# run pkg command
#
proc pkgcmd_dorun {w cmd args} {
    tkbusy_hold
    try {
        $w.cmdout insert end "pkg $cmd\n\n"
        if {[string length $args] > 2} {
            $w.cmdout insert end [exec pkg $cmd -y $args]
        } else {
            $w.cmdout insert end [exec pkg $cmd -y]
        }
        $w.cmdout configure -state "disabled"
    } trap CHILDSTATUS {results options} {
        show_error $results
    }
    tkbusy_forget
}

#
# run pkg command (dry run), whitout applying any changes to the system
#
proc pkgcmd_dryrun {w cmd args} {
    set args_len [string length $args]
    puts "pkgcmd dryrun args len: $args_len"
    tkbusy_hold
    try {
        $w.cmdout insert end "pkg $cmd (dry run)\n\n"
        if {$args_len > 2} {
            puts "pkgcmd dryrun args: $args"
            $w.cmdout insert end [exec pkg $cmd -n $args]
        } else {
            puts "pkgcmd dryrun no args"
            $w.cmdout insert end [exec pkg $cmd -n]
        }
    } trap CHILDSTATUS {results options} {
        set rc [lindex [dict get $options -errorcode] 2]
        if {$rc > 1} {
            show_error $results
        } else {
            $w.cmdout insert end $results
        }
    }
    $w.cmdout configure -state "disabled"
    tkbusy_forget
}

#
# pkg command view
#
proc pkgcmd_view {cmd {args {}} {dorun 0}} {
    global pkgcmd_run
    set pkgcmd_run 0
    set top .view_pkgcmd
    if {[winfo exists $top]} {
        destroy $top
    }
    toplevel $top
    wm transient $top .
    set w $top.view
    ttk::frame $w
    grid rowconfigure $w 0 -weight 1
    grid rowconfigure $w 1 -weight 9
    grid columnconfigure $w 0 -weight 1
    grid $w -sticky nwse
    ttk::button $w.btnrun -text "Run" -command {set pkgcmd_run 1}
    grid $w.btnrun -row 0 -column 0 -sticky w
    text $w.cmdout
    grid $w.cmdout -row 1 -column 0 -sticky nwse
    if {$dorun} {
        pkgcmd_dorun $w $cmd $args
    } else {
        pkgcmd_dryrun $w $cmd $args
        vwait pkgcmd_run
        if {$pkgcmd_run} {
            pkgcmd_view $cmd $args 1
        }
    }
}

#
# installed pkg action buttons
#
proc pkglocal_buttons {w} {
    ttk::button $w.remove -text {Remove} -state {disabled}
    grid $w.remove -row 0 -column 0 -sticky w
    ttk::button $w.upgrade -text {Upgrade} -state {disabled}
    grid $w.upgrade -row 0 -column 1 -sticky w
}

#
# available pkg action buttons
#
proc pkgremote_buttons {w} {
    ttk::button $w.install -text {Install} -state {disabled} \
                           -command {view_pkgcmd_install}
    grid $w.install -row 0 -column 0 -sticky w
}

#
# change state of pkg action buttons
#
proc pkgbuttons_state {w state} {
    global pkgbuttons_curstate
    if {[string equal $pkgbuttons_curstate $state]} {
        return
    }
    set children [winfo children $w]
    set children_len [llength $children]
    for {set i 0} {$i < $children_len} {incr i} {
        set b [lindex $children $i]
        $b configure -state $state
    }
    set pkgbuttons_curstate $state
    update
}

#
# enable pkg action buttons
#
proc pkgbuttons_enable {w} {
    pkgbuttons_state $w {enabled}
}

#
# disable pkg action buttons
#
proc pkgbuttons_disable {w} {
    pkgbuttons_state $w {disabled}
}

#
# packages tree view
#
proc pkgtree_view {w pkgtype pkglist} {
    ttk::frame $w
    grid rowconfigure $w 0 -weight 1
    grid rowconfigure $w 1 -weight 9
    grid columnconfigure $w 0 -weight 1
    grid columnconfigure $w 1 -weight 3
    grid $w -sticky nwse
    ttk::label $w.stats -takefocus 0
    grid $w.stats -row 0 -column 0 -sticky w
    ttk::frame $w.pkgbuttons -takefocus 1
    grid $w.pkgbuttons -row 0 -column 1 -sticky w
    ttk::treeview $w.pkgtree -show tree -selectmode browse -takefocus 1
    grid $w.pkgtree -row 1 -column 0 -sticky nwse
    ttk::label $w.pkginfo -takefocus 0 -padding [list 5 0]
    grid $w.pkginfo -row 1 -column 1 -sticky nw
    tkbusy_hold
    if {[string equal "Available" $pkgtype]} {
        pkgremote_buttons $w.pkgbuttons
    } else {
        pkglocal_buttons $w.pkgbuttons
    }
    set llen [llength $pkglist]
    $w.stats configure -text "$pkgtype packages: $llen"
    set cur_section {}
    set focus_item {}
    for {set i 0} {$i < $llen} {incr i} {
        set line [lindex $pkglist $i]
        set origin [lindex [split $line {|}] 0]
        set pkg_section [lindex [split $origin /] 0]
        set pkg_name [lindex [split $line {|}] 1]
        if {[string equal $cur_section {}]} {
            set focus_item $pkg_section
        }
        if {[string compare $pkg_section $cur_section] != 0} {
            set sid [$w.pkgtree insert {} end -id $pkg_section -text $pkg_section]
            set cur_section $pkg_section
        }
        set pkgid "pkglocal:$pkg_name"
        if {[string equal "Available" $pkgtype]} {
            set pkgid "pkgremote:$pkg_name"
        }
        $w.pkgtree insert $cur_section end -id $pkgid -text $pkg_name
    }
    tkbusy_forget
    $w.pkgtree focus $focus_item
    focus $w.pkgtree
    bind $w.pkgtree <<TreeviewSelect>> {pkg_show %W}
}

#
# view local (installed) packages
#
proc view_pkglocal {w} {
    pkgtree_view $w "Installed" [pkglist_local]
}

#
# view remote (available) packages
#
proc view_pkgremote {w} {
    pkgtree_view $w "Available" [pkglist_remote]
}

#
# dispatch view
#
proc dispatch_view {name} {
    set w .view
    if [winfo exists $w] {
        destroy $w
    }
    $name $w
}

#
# show pkg info
#
proc pkg_show {pkgtree} {
    global pkgtree_selected
    set pkgtree_selected ""
    set w [winfo parent $pkgtree]
    set item [$pkgtree selection]
    set query_format {%n %v (%sh)\n\n%e}
    set pkgremote 0
    if {[string equal {pkglocal:} [string range $item 0 8]]} {
        set pkg [string replace $item 0 8 {}]
        $w.pkginfo configure -text [exec pkg query $query_format $pkg]
        pkgbuttons_enable $w.pkgbuttons
        set pkgtree_selected $pkg
    } elseif {[string equal {pkgremote:} [string range $item 0 9]]} {
        set pkg [string replace $item 0 9 {}]
        $w.pkginfo configure -text [exec pkg rquery $query_format $pkg]
        pkgbuttons_enable $w.pkgbuttons
        set pkgtree_selected $pkg
    } else {
        set slen [llength [$pkgtree children $item]]
        $w.pkginfo configure -text "Category : $item\nPackages : $slen"
        pkgbuttons_disable $w.pkgbuttons
    }
}

#
# show error message
#
proc show_error {msg} {
    tk_messageBox -parent . -title "pkgtk error" -message "$msg" \
                  -type "ok" -icon "error"
}

#
# tk busy hold
#
proc tkbusy_hold {{w .}} {
    tk busy hold $w
    tk busy configure $w -cursor watch
    update
}

#
# tk busy forget
#
proc tkbusy_forget {{w .}} {
    tk busy forget $w
    update
}

#
# pkg list local (installed) packages
#
proc pkglist_local {} {
    try {
        return [split [exec pkg query -e {%a == 0} {%o|%n-%v} | sort -u]]
    } trap CHILDSTATUS {results options} {
        show_error $results
    }
}

#
# pkg list remote (available) packages
#
proc pkglist_remote {} {
    try {
        return [split [exec pkg rquery -a {%o|%n-%v} | sort]]
    } trap CHILDSTATUS {results options} {
        show_error $results
    }
}

#
# main menu
#
proc main_menu {} {
    menu .menu
    . configure -menu .menu

    menu .menu.packages
    .menu add cascade -label "Packages" -underline 0 -menu .menu.packages
    .menu.packages add command -label "Installed" -underline 0 \
                               -command {dispatch_view view_pkglocal}
    .menu.packages add command -label "Available" -underline 0 \
                               -command {dispatch_view view_pkgremote}
    .menu.packages add command -label "Autoremove" -underline 4 \
                               -command {view_pkgcmd_autoremove}
    .menu.packages add command -label "Clean cache" -underline 0 \
                               -command {quit 128}

    .menu add command -label "Quit" -underline 0 -command {quit 0}
}

#
# exit main loop
#
proc quit {rc} {
    destroy .
    exit $rc
}

#
# main
#
proc main {} {
    wm title . pkgtk
    wm minsize . 800 600
    grid rowconfigure . 0 -weight 1
    grid columnconfigure . 0 -weight 1
    . configure -padx 1 -pady 1
    main_menu
    dispatch_view view_pkglocal
}

main
